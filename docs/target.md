## 背景概述

传统的游戏策划案文档编写存在诸多问题，设想下面的场景中，传统的游戏策划案文档编写方式会遇到哪些问题。

### 问题描述

#### 1. 定义模糊，导致需要反复解释
在游戏策划案中，常常需要定义一些核心概念或术语，比如我前段时间参与策划的一个 大富翁like 游戏中，有一个 “终点格” 的 概念，它指的是玩家在一次运动后，移动最终达到的格子（因为有的时候不仅仅是投掷筛子造成的移动，也有可能时道具或者特殊事件造成的移动），这个概念在游戏中是非常重要的，但是它容易被认为成是 大富翁游戏中的起点前的一个格子（因为大富翁中，玩家绕一圈会回到起点），所以我需要在文档中反复解释这个概念。

即使是之后，我将其称呼修改为 “结算格” 之后，仍然需要在文档中反复解释这个概念。

#### 2. 不方便修改
在游戏策划案中，常常需要修改一些核心概念或术语的定义，比如我在上述的 大富翁like 游戏中，最开始我将 “终点格” 定义为 “玩家在一次运动后，移动最终达到的格子”，但是后来我发现这个定义不够准确，所以我将其修改为 “结算格”，但是因为文档中有很多地方都提到了 “终点格”，所以我需要手动去修改所有提到 “终点格” 的地方，这个过程非常繁琐。

还有比如说我需要对于玩家移动的速度做出调整，那么之后，在所有的，我重复了玩家移动速度的地方都需要手动修改。

#### 3. 文档冗长，难以阅读
很多时候，有一些内容被设计为 简述 + 详细描述 的形式，它往往是为了规范边界条件的时候，该如何进行处理。

但是这种方式，导致 开发当想要了解某个 简述对应的 详细描述 时，需要翻阅大量的文档，才能找到对应的内容。

#### 4. 表达自由，语义模糊
写策划案的时候，很容易出现这样一个问题，比如，我想要描述删除一个建筑的行为，但是我可能会有下面几种描述：
- 删除建筑
- 拆除建筑
- 摧毁建筑
- 移除建筑
- 清除建筑
- 设置为空地
- 转换为空地
- 变更为空地

这些描述虽然在语义上是相似的，但是存在传达上的问题，开发并不清楚哪些描述是等价的，哪些描述是有区别的。比如可能拆除简述和移除建筑是等价的，因为它们会返还资源，但是删除建筑和清除建筑等就不一样，指的是不返还资源的。

这个时候就需要策划进行规范表达，将上面存在的多种表达方式确认为两个专属名词，之后将其他的表达方式都指向这两个专属名词。但是有的时候可能会发生疏漏，导致开发在实现的时候，出现了错误的理解。

## 我的解决方案

总体来说，使用 类似于 wiki 的工具，在 悬停在某个词条上时，能够展示该词条的定义和相关信息，可以有效地解决上述问题。此外在此基础上，我还需要一些额外的功能，以便更好地满足我的需求。

### Markdown

我希望使用 markdown 作为基础语言编写文档，因为它是一种轻量级的标记语言，易于阅读和编写，同时也支持基本的格式化功能，比如标题、列表、链接等。

此外它还支持大纲功能，可以方便地查看文档的结构。

### 轻量化
我希望这个工具是轻量化的，能够快速打开和加载文档，因为在编写策划案的时候，可能会需要频繁地查看和修改文档，所以工具的启动速度和加载速度非常重要。

此外，轻量化也能够方便我进行分享，因为我希望其他人能够快速地获取到我的文档，并且能够在他们的设备上快速打开和查看。

### 定义词条
我希望在文档中能够使用一些特殊的语法来定义词条，当我将鼠标悬停在某个词条上时，能够显示该词条的定义和相关信息。

比如说，当我在文档中提到 “滑移” 这个词条时，我希望能够在鼠标悬停在 “滑移” 上时，能够显示 “滑移” 的定义和相关信息。
如果定义中引用了其他地方的定义，那么在悬停卡片上悬停在其中的引用定义时，也会进一步展示一个悬停卡片来介绍其定义。

我们使用单个文件来定义一个词条的定义和相关信息，文件名不会影响判断，只会影响定义来源标记，只有 alias 才会影响定义的展示。
比如格式约定为：
基础移动方式.md
```md
---
alias: 
    - 滑移
    - 基础移动方式
---
## 概述
滑移是游戏中玩家的主要移动方式之一，它允许玩家在地图上滑动到指定位置。
在滑动过程中，玩家不允许改变运动的方向，直到运动停止，之后玩家可以选择新的方向进行滑动。
```

之后，在其他文档中，只要提到 “滑移” 或 “基础移动方式”，那么鼠标悬停在这些词条上时，就会显示上述的定义。

```md
玩家【滑移】结束后，会对终点位置的下一格产生冲击，该冲击可以触发一些特殊事件，比如说触发陷阱或者与其他玩家发生碰撞。
```
这里的 【滑移】会被自动识别为一个词条，并且在鼠标悬停时显示其定义和相关信息。

### 文件夹结构无关

我希望词条的定义和相关信息能够与文件夹结构无关，因为有时候我可能会将某个词条的定义放在一个单独的文件中，而不是放在与该词条相关的文件夹中。

当一个名词在多个文件夹中都有定义时，它能够自动识别并展示所有的定义，而不是只展示一个文件夹中的定义。类似于

```md
来自 XXX.md 的定义(灰色小字)
这是一段描述
---
来自 YYY.md 的定义(灰色小字)
这是一段描述
这是一段描述
```

### 便于分享
我希望这个工具能够便于分享，其他人拿到我的链接或者拿到我的程序和文件之后，也能够获得上述体验。

比较理想的方式是，其他人只需要打开我的程序之后，host 一个本地的 webui 服务，然后在浏览器中打开本地的 webui 服务，就能够查看我的文档，并且能够在鼠标悬停时显示词条的定义和相关信息。

### 监听修改
当我修改了某个词条的别名后，其他只要使用了该别名的文档，都能够自动更新为新的别名。


### 空缺模板匹配
我希望能够使用一些特殊的语法来定义带有空缺的模板，比如说在文档中提到 “使用 {滑移} 替换 {基础移动方式} 的定义”，那么当鼠标悬停在 {滑移} 上时，能够显示 “滑移” 的定义和相关信息，而当鼠标悬停在 {基础移动方式} 上时，能够显示 “基础移动方式” 的定义和相关信息。当 悬浮到 使用 {滑移} 替换 {基础移动方式} 的定义 时，能够显示 “使用 {} 替换 {} 的定义” 的定义和相关信息。

比如
使用A替换B.md
```md
---
alias: 
    - 使用{A}替换{B}的定义
---
## 概述
使用 {A} 替换 {B} 指的是，将某个模式 {B} 的逻辑替换为使用 {A}。
```

之后在其他地方使用该定义
```md
在游戏中，玩家可以【使用 {滑移} 替换 {基础移动方式} 的定义】。
```

之后当鼠标悬停在 “使用 {滑移} 替换 {基础移动方式} 的定义” 上时，能够显示下面内容
```
## 概述
使用 滑移 替换 基础移动方式 指的是，将某个模式 基础移动方式 的逻辑替换为使用 滑移。
```

如果使用定义嵌套：
```md
在游戏中，玩家可以【使用 {【滑移】} 替换 {【基础移动方式】} 的定义】。
```
那么当鼠标悬停在 “使用 {【滑移】} 替换 {【基础移动方式】} 的定义” 上时，能够显示下面内容
```
## 概述
使用 【滑移】 替换 【基础移动方式】 指的是，将某个模式 【基础移动方式】 的逻辑替换为使用 【滑移】。
```

之后在这个内容上进一步悬停在 【滑移】 上时，能够显示 滑移 的定义和相关信息，而悬停在 【基础移动方式】 上时，能够显示 基础移动方式 的定义和相关信息。

### 文件内定义

有的时候，某些定义只需要在当前文档中生效，而不需要在全局生效，比如说在某个文档中，我需要定义一个 “施法者” 和 “目标” 的概念，但是这个概念只在当前文档中生效，而不需要在全局生效。
我希望能够使用一些特殊的语法来定义 文件内定义，比如说在文档中使用
```md
【施法者】：XXXX
【目标】：YYYY
```
的方式来创建一个只作用于当前文档的文件内定义。之后鼠标悬停在当前文件的 【施法者】 或 【目标】 上时，能够显示对应的定义和相关信息。

### 区域定义

我们可能希望在整个文档库中，编写多个游戏的策划案文档，而每个游戏的策划案文档中，可能会有一些相同的概念，比如说 “玩家” 和 “NPC” 等等，但是同时，它们可能在不同的游戏中有不同的定义。
我希望能够使用一些特殊的语法来定义 区域定义，比如说在文档中使用
game1/npc.md
```md
---
scope: game1
---
在游戏1中，NPC 指的是非玩家控制的角色，它们通常是游戏世界中的背景角色或者敌对角色。
```

game2/npc.md
```md
---
scope: game2
---
在游戏2中，NPC 指的是非玩家控制的角色，在本游戏中，它们时玩家的对手，它们会与玩家进行战斗。
```

npc.md
```md
---
// 不填scope，表示全局定义
---
NPC (Non-Player Character) 指的是非玩家控制的角色，它们通常是游戏世界中的背景角色或者敌对角色。
```

此时，如果一个文件中想要引用某个区域定义，可以使用
```md
---
scope: game1
---
【NPC】 拥有下述几种属性：……
```

此时将鼠标悬停在 【NPC】 上时，能够显示如下内容：
```
来自game1的区域定义（灰色小字）
在游戏1中，NPC 指的是非玩家控制的角色，它们通常是游戏世界中的背景角色或者敌对角色。
---
来自全局定义（灰色小字）
NPC (Non-Player Character) 指的是非玩家控制的角色，它们通常是游戏世界中的背景角色或者敌对角色。
```

而不会显示 game2 的区域定义。因为这个文档限定的 scope 是 game1，所以只会显示 game1 的区域定义和全局定义。

但是我们也提供额外的方式来直接指定其他区域定义，比如说在文档中使用
```md
【game2/NPC】 拥有下述几种属性：……
```

此时将鼠标悬停在 【game2/NPC】 上时，能够显示如下内容：
```
来自game2的区域定义（灰色小字）
在游戏2中，NPC 指的是非玩家控制的角色，在本游戏中，它们
时玩家的对手，它们会与玩家进行战斗。
---
来自全局定义（灰色小字）
NPC (Non-Player Character) 指的是非玩家控制的角色，它们通常是游戏世界中的背景角色或者敌对角色。
```

注意 这里虽然使用了 game2/NPC 。但是区域和文件夹目录结构无关，而是只会根据 scope 来决定区域定义的范围。

### 自动修复

当 【】 内的文本没能够找到对应的定义时，展示一个错误卡片，内容大概如下：
```
【滑动】的定义未找到，请检查拼写或定义是否存在。
---
下面是近似的定义：
- 【滑移】：来自于基础移动方式.md
- 【滑动方式】：来自于交互设计.md
- 【滑动解锁】：来自于谜题设计.md
```

### 策划公式

latex 在 markdown 中提供了一个功能非常齐全的公式编辑器，但是对于游戏策划案来说，设计方程式永远没有传达逻辑关系更为重要，因为不论如何设计一个公式，它都能够被声明为 function Y(args[]) , 只要声明为了这个，那么实际上后续如果需要修改公式，开发都可以通过修改 function 的实现来完成。只要它的输入和输出是正确的，那么就可以了。

所以我希望能够使用一些特殊的语法来描述策划公式，比如说在文档中使用
```md
%% [伤害] = <暴击率> * (<暴击伤害> + 1) * <攻击力> * (1-[防御减伤比例]) %%
%% [实际伤害] = [伤害] * (1 - <减伤比例>) - <固定减伤值> %%
```
其中 `<暴击率>` 、 `<攻击力>` 、 `<暴击伤害>` 和 `<防御减伤比例>` 是设计值，它们是从游戏中获取的值，或者是由策划直接指定的值
而 `[伤害]` 和 `[实际伤害]` 是计算值，它是由 `<暴击率>`、`<暴击伤害>`、`<攻击力>` 和 `<防御减伤比例>` 计算得来的。

换句话说，上面的公式实际上描述的是：
```c#
float CalculateDamage(float critRate, float critDamage, float attackPower, float defenseReductionRate) {
    return critRate * (critDamage + 1) * attackPower * (1 - defenseReductionRate);
}

float CalculateActualDamage(float damage, float damageReductionRate, float fixedReductionValue) {
    return damage * (1 - damageReductionRate) - fixedReductionValue;
}

actualDamage = CalculateActualDamage(CalculateDamage(critRate, critDamage, attackPower, defenseReductionRate), damageReductionRate, fixedReductionValue);
```

假设后续我需要修改公式，那么也只是修改 `CalculateDamage` 和 `CalculateActualDamage` 的实现即可，而不需要修改其他地方的代码。


进行了上述定义后，当鼠标悬停在 `[伤害]` 上时，能够显示 `[伤害]` 的 （区域定义 | 全局定义）（如果有）和计算方式（如果有），而鼠标悬停在 `<减伤比例>` 上时，能够显示 `<减伤比例>` 的 （区域定义 | 全局定义）（如果有），它没有计算方式，因为它是一个设计值。

*有区域定义的时候，区域定义展示在全局定义之前，且区域定义的优先级高于全局定义。*

比如文档中：
```
【伤害】：玩家造成的伤害，不是实际值，但是会传递给目标进行下一步计算
【实际伤害】：玩家造成的实际伤害，经过减伤计算后的值
【暴击率】：玩家的暴击率
【暴击伤害】：玩家的暴击伤害，计算玩家暴击了之后的伤害应该是 攻击力 * (1 + 暴击伤害)
【攻击力】：玩家的攻击力

%% [伤害] = <暴击率> * (<暴击伤害> + 1) * <攻击力> * (1-[防御减伤比例]) %%
%% [实际伤害] = [伤害] * (1 - <减伤比例>) - <固定减伤值> %%
```

那么当鼠标悬停在 `[伤害]` 上时，能够显示如下内容：
```
玩家造成的伤害，不是实际值，但是会传递给目标进行下一步计算

[伤害] = <暴击率> * (<暴击伤害> + 1) * <攻击力> * (1-[防御减伤比例])
```

当鼠标悬停在 `<暴击率>` 上时，能够显示如下内容：
```
玩家的暴击率
```

当鼠标悬停在 `<减伤比例>` 上时，不显示悬浮卡片，因为它是一个设计值，且没有区域定义或者全局定义。

当鼠标悬停在 `[实际伤害]` 上时，能够显示如下内容：
```
玩家造成的实际伤害，经过减伤计算后的值

[实际伤害] = [伤害] * (1 - <减伤比例>) - <固定减伤值>
```

在该卡片上进一步悬停能够继续展开
```
玩家造成的伤害，不是实际值，但是会传递给目标进行下一步计算

[伤害] = <暴击率> * (<暴击伤害> + 1) * <攻击力> * (1-[防御减伤比例])
```

## 开发

### 技术栈

请你使用 以下技术栈来实现上述功能：

我们不使用前后端的设计模式，而是使用build一个静态网页的方式来实现。通过将本地的 markdown 渲染为静态的 HTML 页面，并且使用 JavaScript 来实现词条的悬停卡片功能。

我们 直接使用 vuepress 来实现静态网页的构建和 markdown 的渲染。并且使用 vue + TypeScript 来实现对于 markdown 的处理和构建组件化的悬停卡片功能。

本项目使用 TypeScript 进行类型检查，确保代码的类型安全。
使用 pnpm 作为包管理工具，确保依赖的管理和安装。

### 实现方式

实际上只需要做的不应该是：创建一个插件，执行以下操作：
1. 遍历所有文件，创建一个索引文件（但是不要使用db，那样的话太笨重了）
2. 当开始渲染 markdown 的时候，按照我的需求：
【】：渲染为文档内定义，
【】渲染为定义引用，并且使用vuepress 的 vue 支持功能，渲染浮动卡片出来
%% %% 渲染为策划公式
1. 将必要的辅助代码放到 .vuepress/client.ts 中

### 开发规范

1. 先规划，后开发
   - 在开始开发之前，先规划好项目的结构和功能模块，确保代码的可维护性和可扩展性。
   - 使用 markdown 文档记录项目的设计思路和实现细节。
   - 在开发过程中，及时更新文档，确保文档与代码保持一致。

2. 代码规范
   - 使用 TypeScript 进行类型检查，确保代码的类型安全。
   - 使用 模块化 和 解耦 的方式组织代码，确保代码的可读性和可维护性。确保单个文件不要超过 400 行代码，否则ai 的处理难度将会增加。
   - 编写测试用例，来确保每个单元的功能正确性。同时也能够简化后续的维护工作。

3. 文件夹规范
    - `note/`：存放所有的文档内容，比如 本项目的开发目标、开发文档、开发进度，架构设计等。
    - `tests/`：存放测试用例的代码，使用 jest 来实现单元测试。
    - `docs/`：存放项目的文档，比如 API 文档、用户手册等。

4. 禁止任何的盲目猜测和想当然
    - 在开发过程中，禁止任何的盲目猜测和想当然，所有的代码都需要有明确的需求和设计。
    - 如果你不确定 vuepress 的某个 API 的用法或者某个功能的实现方式，请先查阅文档，我已经将所有的相关文档放在了 `reference/vuepress-doc/` 目录下。它同时也是 vuepress 的官方示例。

